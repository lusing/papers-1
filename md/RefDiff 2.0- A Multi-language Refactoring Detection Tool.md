# RefDiff 2.0: A Multi-language Refactoring Detection Tool

## Abstract

Identifying refactoring operations in source code changes is valuable to understand software evolution. Therefore, several tools have been proposed to automatically detect refactorings applied in a system by comparing source code between revisions. The availability of such infrastructure has enabled researchers to study refactoring practice in large scale, leading to important advances on refactoring knowledge. However, although a plethora of programming languages are used in practice, the vast majority of existing studies are restricted to the Java language due to limitations of the underlying tools. This fact poses an important threat to external validity. Thus, to overcome such limitation, in this paper we propose RefDiff 2.0, a multi-language refactoring detection tool. Our approach leverages techniques proposed in our previous work and introduces a novel refactoring detection algorithm that relies on the Code Structure Tree (CST), a simple yet powerful representation of the source code that abstracts away the specificities of particular programming languages. Despite its language-agnostic design, our evaluation shows that RefDiff’s precision (96%) and recall (80%) are on par with state-of-the-art refactoring detection approaches specialized in the Java language. Our modular architecture also enables one to seamlessly extend RefDiff to support other languages via a plugin system. As a proof of this, we implemented plugins to support two other popular programming languages: JavaScript and C. Our evaluation in these languages reveals that precision and recall ranges from 88% to 91%. With these results, we envision RefDiff as a viable alternative for breaking the single-language barrier in refactoring research and in practical applications of refactoring detection.

识别源代码更改中的重构操作对于了解软件演进非常有价值。因此，已经提出了几种工具，可以通过比较版本之间的源代码来自动检测系统中应用的重构。这种基础设施的可用性使研究人员能够大规模研究重构实践，从而在重构知识方面取得了重要的进步。但是，尽管实践中使用了大量编程语言，但是由于底层工具的限制，绝大多数现有研究仅限于Java语言。这一事实对外部有效性构成了重大威胁。因此，为了克服这种限制，在本文中我们提出了RefDiff 2.0，一种多语言重构检测工具。我们的方法利用了先前工作中提出的技术，并引入了一种新颖的重构检测算法，该算法依赖于代码结构树（CST），这是一种简单而强大的源代码表示形式，抽象了特定编程语言的特殊性。尽管采用了与语言无关的设计，但我们的评估表明RefDiff的精度（96％）和召回率（80％）与Java语言专用的最新重构检测方法相当。我们的模块化体系结构还使人们能够通过插件系统无缝扩展RefDiff以支持其他语言。为了证明这一点，我们实现了插件以支持其他两种流行的编程语言：JavaScript和C。我们对这些语言的评估表明，准确性和召回率介于88％至91％之间。有了这些结果，我们设想RefDiff是在重构研究和重构检测的实际应用中打破单一语言障碍的可行替代方案。

## 1 INTRODUCTION

## 2 BACKGROUND

## 3 PROPOSED APPROACH

## 4 EVALUATION WITH JAVA PROJECTS

## 5 EVALUATION WITH JAVASCRIPT AND C

## 6 CHALLENGES AND LIMITATIONS

Low-level refactorings: RefDiff does not detect local refactorings, such as rename, extract or inline a local variable, because the syntactical structure of the source code within a CST node is not represented. While it is theoretically possible to extend the CST to include finer-grained code elements such as statements, local variables, and others, this would also make it harder to port RefDiff to other programming languages.

低级重构:RefDiff不检测局部重构，例如重命名、提取或内联局部变量，因为CST节点内的源代码的语法结构没有被表示出来。虽然理论上可以扩展CST以包含更细粒度的代码元素，如语句、局部变量等，但这也会使将RefDiff移植到其他编程语言变得更加困难。

Generating call graphs: In our modular architecture, the generation of the CST, which includes information from a call graph and a type hierarchy graph, is delegated to a language-specific plugin. For languages such as Java, there are reliable parsers and static analyzers that aid in this task (e.g., Eclipse JDT). However, we acknowledge that generating precise call graphs for untyped languages, such as JavaScript, might be a challenging problem. Nevertheless, we provided evidences that our approach works well even when the information encoded in the CST is not completely precise. For example, in our JavaScript implementation— which contains only 689 lines of code in total—we used a simple strategy in which we assume a node n1 uses n2 if n1 contains a function call with the same identifier as n2 and both are defined in the same file. However, to detect a Extract relationship between n1 and n2, we need two other conditions: (i) n2 should be a new method and (ii) the body of n2 should be similar to the code removed from n1 between revisions. In other words, an incorrect edge in the call graph only leads to an incorrect Extract relationship in the unlikely scenario in which a function n2 is introduced, the content of such function is similar to code removed from n1 and n1 calls a function with the same identifier of n2 after the change, but that function is not actually n2. A similar reasoning applies to Inline relationships, which also depends on information from call graphs. In summary, although generating precise call graphs is non trivial for untyped languages, we argue that it is not needed in practice to achieve acceptable precision, specially in the light of the results of our evaluation using JavaScript systems (91% of precision).

生成调用图:在我们的模块化架构中，CST的生成，包括来自调用图和类型层次图的信息，被委托给特定语言的插件。对于像Java这样的语言，有可靠的解析器和静态分析器可以帮助完成这项任务(例如Eclipse JDT)。然而，我们承认，为非类型性语言(如JavaScript)生成精确的调用图可能是一个具有挑战性的问题。尽管如此，我们提供的证据表明，即使在CST编码的信息不是完全精确的情况下，我们的方法也能很好地工作。例如，在我们的JavaScript实现(总共只包含689行代码)中，我们使用了一个简单的策略，假设节点n1使用n2，如果n1包含一个与n2标识符相同的函数调用，并且两者都在同一个文件中定义。然而，要检测n1和n2之间的提取关系，我们还需要另外两个条件:(i) n2应该是一个新方法;(ii) n2的主体应该类似于在两次修订之间从n1中删除的代码。换句话说,一个错误的调用图的边缘只会导致一个不正确的提取关系可能场景,在该场景中,n2介绍函数,这些函数类似于代码的内容从n1和n2的n1与相同的标识符调用一个函数后改变,但这个函数实际上不是n2。类似的推理也适用于内联关系，它也依赖于来自调用图的信息。总之，尽管生成精确的调用图对于非类型化语言来说不是一件容易的事，但我们认为在实践中不需要达到可接受的精度，特别是根据我们使用JavaScript系统评估的结果(精度为91%)。

JavaScript class syntax: Our JavaScript implementation only considers classes defined with the new ES6 syntax, i.e., classes emulated by functions definitions and prototypebased inheritance are just treated like regular functions when generating the CST.

JavaScript类语法:我们的JavaScript实现只考虑用新的ES6语法定义的类，也就是说，函数定义和基于原型的继承所模拟的类在生成CST时被视为常规函数。

Field-related refactorings: As our refactoring detection algorithm is centered around code similarity and fields do not have a body, we did not implement the detection of Move/Pull Up/Push Down Field in RefDiff 2.0. Unrestricted detection of Move Field based solely on fields’ types and names is prone to find many false positives. However, we plan to add support for field-related refactorings in future work by using stricter detection rules, similarly to RMiner (e.g., requiring a dependency between their source and destination classes).

字段相关的重构:由于我们的重构检测算法是围绕代码相似性和字段没有主体，我们没有在RefDiff 2.0中实现移动/上拉/下推字段的检测。仅根据字段的类型和名称进行无限制的移动字段检测，容易出现大量误报。然而，我们计划在未来的工作中增加对字段相关重构的支持，方法是使用更严格的检测规则，类似于RMiner(例如，要求源类和目标类之间存在依赖关系)。

## 7 CONCLUSION

To the best of our knowledge, RefDiff 2.0 is the first refactoring detection approach that supports multiple programming languages. We made this possible with two main design decisions. First, our refactoring detection algorithm relies only on information encoded in CSTs, a data structure that represents the source code but abstracts the specificities of each programming language. Second, we compute code similarity at the level of the tokenized source code, using techniques from information retrieval. In summary, RefDiff is loosely coupled to the syntax of the target programming language, which makes it easier to extend it to other languages. Our evaluation using a dataset of real refactorings in Java showed that RefDiff’s precision is 96.4% and recall is 80.4%. Although we were not able to surpass RMiner’s precision of 98.8%, we argue that we achieved satisfactory results for a language-neutral approach. In one hand, specialized tools can use more advanced techniques to improve refactoring detection. On the other hand, the higher the coupling with the syntax of a particular language, the harder it becomes to port the approach to other programming languages. Last, our evaluation in JavasScript and C also showed promising results. RefDiff’s precision and recall are respectively 91% and 88% for JavaScript, and 88% and 91% for C. These results show the viability our approach for languages other than Java. Thus, we claim that RefDiff 2.0 can pave the way for important advances in refactoring studies in JavaScript, C, and other languages in the future. Moreover, it can be employed in practical tasks, such as improving diff visualization, automatically documenting refactorings in commits, keeping track of the history of refactored code elements, and others.

据我们所知，RefDiff 2.0是第一种支持多种编程语言的重构检测方法。我们通过两个主要的设计决策使之成为可能。首先，我们的重构检测算法仅依赖于以CST编码的信息，CST是表示源代码但抽象了每种编程语言的特性的数据结构。其次，我们使用信息检索中的技术在标记化的源代码级别上计算代码相似性。总之，RefDiff与目标编程语言的语法松散耦合，这使得将其扩展到其他语言变得更加容易。我们使用Java中的真实重构数据集进行的评估显示RefDiff的精度为96.4％，召回率为80.4％。尽管我们无法超过RMiner的98.8％的精确度，但我们认为通过语言无关的方法我们取得了令人满意的结果。一方面，专用工具可以使用更高级的技术来改善重构检测。另一方面，与特定语言的语法的耦合度越高，将方法移植到其他编程语言的难度就越大。最后，我们在JavasScript和C中的评估也显示出令人鼓舞的结果。 RefDiff的JavaScript精确度和召回率分别为91％和88％，C的精确度和召回率分别为88％和91％。这些结果表明，我们的方法适用于Java以外的其他语言。因此，我们认为RefDiff 2.0可以为将来在JavaScript，C和其他语言中进行重构研究的重要进展铺平道路。而且，它可以用于实际任务中，例如改进diff可视化，自动记录提交中的重构，跟踪重构的代码元素的历史记录等。
